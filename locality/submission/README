**************************************************************************
*                                PPMTRANS                                *
*       BY CAMILLE CALABRESE (ccalab04) AND SOPHIA WANG (swang30)        *
*                 OCTOBER 2019 FOR COMP 40 ASSIGNMENT 3                  *
**************************************************************************

**************************** ACKNOWLEDGEMENTS ****************************

Thank you to Megan Monroe, who helped us during her office hours last week,
and Josh Simani, who helped us understand the UArray methods interface.

The UArray2 plain interface was originally written for the iii assignment,
so it was written with the help of Andreas Moe (amoe01), Camille's hw2
partner.

************************* IMPLEMENTATION SUCCESS *************************

As far as we can tell, we have successfully implemented all of the
transformations, including the optional ones. Any problems with our
program output we had could be traced to an issue uploading large image
files to the server. We hope the checked runtime errors have been
implemented correctly, but we are not always sure whether we should catch
an exception and keep the program going or if we should abort the program.

One bug is that the program doesn't really work on image files named "-".

If we were to change something, we would add code to stop the program
from entering the map function if the rotation is 0 degrees. Instead we
would write the original image and then quit.

We also would make block major transformations faster.

****************************** ARCHITECTURE ******************************

Our solution offers two methods suites for UArray2, each of which
corresponds to a different underlying data structure. The
uarray2_methods_plain corresponds to a plain UArray2, whereas
uarray2_methods_blocked works with blocked UArray2s. However, they are
both of the same type and therefore offer essentially the same functions.

A plain UArray2 is an unboxed, two dimensional array. The column coordinate
always goes first, so the indices are effectively organized in column major
order. The structure underlying a UArray2 is a single Hanson UArray_T, which
is a one dimensional unboxed array. Whenever an array bucket needs to be
accessed, a private function converts two dimensional coordinates into the
corresponding one dimensional index in the Hanson array. It offers row major
and column major mapping functions that use a simple nested loop for row and
column coordinates.

A UArray2b relies on the same underlying structure of a Hanson UArray_T,
like the plain UArray2, but it works somewhat differently. It is organized
into blocks, or square regions within the array. The main functional
aspect that separates it from the plain UArray2 is the way coordinates
are converted between one dimensional and two dimensional, and vice versa,
to preserve the key invariant that array blocks are stored in contiguous
sections of memory. Instead of offering row major or column major mapping
functions, it offers its own block major mapping function which reflects the
unique organization of the array elements. Although the methods in the
blocked array are rather different in order to create the different
organization of the array, the actual storage of the elements is still
simply a one dimensional Hanson unboxed array.

The architecture of ppmtrans relies mostly on the uarray2 methods and pnm
interfaces. It identifies the transformation to be performed and calls the
map function from the methods suite to perform it. The key feature of this
program is the coords_calcs interface, which contains arithmetic functions
for translating coordinates in different ways, such as rotations, tranposing,
and flipping.

A simple but crucial struct is Coordinates. It is used by a variety of
functions in Uarray2b and ppmtrans to return both column and row coordinates
in a simple way.

Finally, one more niche structure is the transform_closure struct in ppmtrans.
It is defined at the top of ppmtrans.c and simply allows the client to pass
a lot of necessary information into the transform mapping function. One
interesting thing about it is it contains a function pointer which points to
one of the functions in coords_calcs, allowing the same "transform" function
to be used for all kinds of transformations.

************************** PART E: EXPERIMENTAL **************************

One of our test images was a 501 x 625 image of Megan, but the program
handled it so quickly we will not include the results here because the
execution may have been too fast to give reliable results.

For all of our tests, we piped the output to a .pnm image file and took
the input from a .pnm file.

Furthermore, all of our tests were run on landscape images, meaning the
images were all wider than they were tall. For future tests, we would be
interested to see what the results are for a portrait-oriented image and
compare that to the results we got here.

Our methodology consisted of starting the timer just before the map
function was called and stopping it just after the map function was
completed. Therefore, our times do not include operations such as reading
in the original image or creating arrays, they only time the transformation
itself.

Computer Details: Intel i7-6700, 3.40 GHz, 4 cores
                  Dell Precision Tower 3420

Our analysis can be found below the tables.

T  = "Total"
PP = "per pixel"
*** NOTE: Measurements are in Nanoseconds. Nanoseconds are 1 billionth of
          a second, so the number of nanoseconds is roughly equal to the
          number of CPU instructions. For example, for the Obama photo, 0
          degree rotation, col major, the rotation took roughly 54 nanoseconds
          per pixel.
          1 second / 1,000,000,000 nanoseconds per second * 1,000,000,000
          CPU instructions per second = 1 CPU instruction per nanosecond
          OR
          1 nanosecond / 1,000,000,000 nanoseconds per second * 1,000,000,000
          CPU instructions per second = 1 CPU instruction per nanosecond
          EXAMPLE
          53.876258 nanoseconds = 0.000000053876258 seconds = 53.876258 CPU
          instructions

__________________________________________________________________________
|                           obama.pnm: 3108 x 2331                       |
__________________________________________________________________________
|                 | Col major       | row major       | block major      |
__________________________________________________________________________
| 0 degrees       | T : 390319916   | T : 336425081   | T : 788666876    |
|                 | PP: 53.876258   | PP: 46.437099   | PP: 108.860498   |
__________________________________________________________________________
| 90 degrees      | T : 412687276   | T : 375609347   | T : 829887584    |
|                 | PP: 56.963648   | PP: 51.845744   | PP: 114.550235   |
__________________________________________________________________________
| 180 degrees     | T : 470534849   | T : 413029880   | T : 879362646    |
|                 | PP: 64.948408   | PP: 57.010938   | PP: 121.379328   |
__________________________________________________________________________
| 270 degrees     | T : 486816322   | T : 476385599   | T : 930437301    |
|                 | PP: 62.7195756  | PP: 65.755993   | PP: 128.429215   |
__________________________________________________________________________
| flip horizontal | T : 416840838   | T : 345066977   | T : 806801794    |
|                 | PP: 57.536969   | PP: 47.629949   | PP: 111.363679   |
__________________________________________________________________________
| flip vertical   | T : 385879829   | T : 349102706   | T : 816029928    |
|                 | PP: 53.263389   | PP: 48.187005   | PP: 112.637448   |
__________________________________________________________________________
| transpose       | T : 403052583   | T : 364828224   | T : 822814859    |
|                 | PP: 55.633762   | PP: 50.357614   | PP: 113.573979   |
__________________________________________________________________________

__________________________________________________________________________
|                        mobo.pnm: 8160 x 6120                           |
__________________________________________________________________________
|                 | Col major       | row major        | block major     |
__________________________________________________________________________
| 0 degrees       | T:3016308973    | T:2318113160   | T:5480941011
                  | PP:60.399625    | PP:46.418708   | PP:109.752279
__________________________________________________________________________
| 90 degrees      | T: 273673929    | T:249009561    |  T: 5714615654
                  | PP:54.801424    | PP:51.864980   |  PP:114.431462
__________________________________________________________________________
| 180 degrees     | T:3401514648    | T:2828750544   |  T:6047547398
                  | PP:68.113119    | PP:56.643890   |  PP:121.098203
__________________________________________________________________________
| 270 degrees     | T:3406988925    | T:3372994196   | T:6399227278
                  | PP:68.222737    | PP:67.542015   | PP:128.140364
__________________________________________________________________________
| flip horizontal | T:2808438483    | T:237217806    | T:5576206363
                  | PP:56.237154    | PP:47.501334   | PP:111.659906
__________________________________________________________________________
| flip vertical   | T:2858117826    | T:2402833403   | T:5567174220
                  | PP:57.231951    | PP:48.115176   | PP:111.479043
__________________________________________________________________________
| Transpose       | T:2671882630    | T:2489027499   | T:5584104919
                  | PP:53.502712    | PP:49.841157   | PP:111.818069
__________________________________________________________________________

__________________________________________________________________________
|                            tajmahal.pnm: 11081 x 6247                  |
__________________________________________________________________________
|                 | Col major      | row major      | block major        |
__________________________________________________________________________
| 0 degrees       | T:3751128611   | T:319853373    | T:8084947619
                  | PP:54.189045   | PP:46.206227   | PP:116.795672
__________________________________________________________________________
| 90 degrees      | T: 3669668852  | T:3604068231   | T:7936939707
                  | PP:53.012272   | PP:52.064601   | PP:114.657540
__________________________________________________________________________
| 180 degrees     | T:4516374923   | T:3965101364   | T:8388740799
                  | PP:65.243842   | PP:57.280109   | PP:121.184288
__________________________________________________________________________
| 270 degrees     | T:4625459303   | T:45564999927  | T:8897507354
                  | PP:66.819682   | PP:65.830713   | PP:128.533962
__________________________________________________________________________
| flip horizontal | T: 3871210665  | T:3271167389   | T:7717515706
                  | PP:65.923758   | PP:47.255494   | PP:111.487727
__________________________________________________________________________
| flip vertical   | T:3760135451   | T:3345024088   | T:7672413491
                  | PP:54.319158   | PP:48.322433   | PP:110.836178
__________________________________________________________________________
| Transpose       | T: 3536194463  | T:3465058586   | T:7754879125
                  | PP:51.084092   | PP:50.056459   | PP:112.027481
__________________________________________________________________________


ANALYSIS

Despite our predictions to the contrary, row major is the fastest, with
column major a close second and block major much slower.

Although we are not seriously considering the results from the Megan photo, it
is worth noting that column major was slightly faster than row major when
transforming that photo, which was in portrait orientation. In future tests, it
would be interesting to see if this trend applies to larger portrait photos.

The number of instructions per pixel among row major, column major, and
block major remained remarkably consistent regardless of image size. The main
fluctuations in these measurements are related to the type of transformation.

The row major times fluctuated the most between different kinds of
transformations compared to the overall size of the measurements. However,
even the row major times per pixel were, again, very consistent for different
sized photos.

We theorize that the increased complexity of our coordinates
calculators for rotations is the reason that rotations seem to generally
take longer. Whereas the flip and transpose calculators simply perform an
arithmetic operation, the rotation calculator runs a loop that calls another
function to perform an arithmetic operation for every 90 degrees in the
rotation. This would also explain why rotations of more degrees take longer
than rotations of fewer degrees, with the exception of 0 degrees, which is
sometimes slower than the 90 degree rotation.

Because the higher degree rotations aren't all that much slower than their
lower degree counterparts, and all coordinates calculator functions are
essentially just basic arithmetic operations, our guess is that the effect of
the coordinate calculator functions, while noticeable, is small and is not
the cause of the most serious speed bottleneck. This is reinforced by the
fact that variance in the times for different mapping function is much more
severe than variance in times between types of transformations.

Overall, we were surprised that the order from fastest to slowest was
consistently row-major, col-major, and then block-major as a distant third.
We were also surprised that this held firm despite the size of the image or
the type of rotation. On the other hand, we were impressed that the time per
pixel remained so consistent for any size image.

POSSIBLE EXPLANATIONS

One possible explanation for why the block major mapping is so much slower
could be that the map functions for the plain arrays both exhibit
good locality, or locality isn't the most relevant factor in program speed.
Then, since optimizing locality isn't much of an issue, the extra
calculations that go into block major mapping slow the program down
severely, causing it to be only half as fast as the other two mapping modes.

What confused us the most was that row and column major had very similar
performance, with row major actually being a bit faster. Since in C the
spatial locality is better when the second index of a 2D array changes faster
(even when the underlying structure is a 1D array, because this is the case
in memory no matter what the code actually looks like), we had expected col
major mapping to be much faster than row major. Therefore, one possible
explanation is that the computer we tested on was simply so powerful that
spatial locality in our program actually didn't matter too much. We feel we
can rule out the idea of the entire image fitting in the cache at once because
our tajmahal image is roughly 20 MB which certainly doesn't fit entirely in
the cache. Therefore, our best idea so far is that locality simply wasn't
the determining factor of speed in this program because some kind of
processing in the CPU caused the speed bottleneck, rather than cache misses.
This would explain why the measurements for row and col major are so similar
to each other.

This still doesn't account for the slight edge that row major had over
column major. Although the Megan image was too small (and processed too
quickly) for us to seriously consider, we did see column major performing
slightly better than row major for that image, which inspired Sophia to come
up with a theory that we have yet to test. Basically, Sophia's theory is
that the difference between row major and column major speed depends on the
orientation of the image. Since all of our test images were landscape
oriented, row major was faster because rows were longer than columns. We
don't really have the expertise to explain why this would make a difference,
but it certainly is an intriguing hypothesis.

Another theory to test would be to try this same program but on pbm images.
We imagine a PBM image takes next to no processing power to manipulate,
meaning the emphasis (and therefore the speed bottleneck) would be on the
memory speed constraints associated with reading and writing the arrays.
Then we could see if locality has more of an effect. Finally, another
worthwhile experiment would be to time a larger swath of
the program, including Pnm_ppmread and Pnm_ppmwrite, although we aren't so
sure what this would tell us.

Overall, we have guessed that the coordinates transformation calculators are
not the greatest speed bottleneck, and neither is cache miss rate. The fact
that block major is vastly slower whereas row and column major have similar
speeds suggests that the source of the bottleneck is the functions to
convert two dimensional coordinates to one dimensional. This function is much
more complicated for the blocked array, which would explain the doubled
time per pixel for this technique. It can't really explain the speed
difference between row and column major, but it does explain the largest
speed difference.

In conclusion, we suspect that the speed bottleneck of this particular
program pertains not to memory access but to processing power instead
because the mapping form that involved more arithmetic operations (block
major) was vastly slower than the other two, column major was slower than
row major even though column major mapping exhibits better spatial locality
(and none of the mapping formats exhibit particularly good temporal locality,
especially for rotations). These things suggest that maximizing cache hits
doesn't actually have a huge effect on the speed of this program because the
speed bottleneck is caused by something else.

***************************** TIME COMMITMENT ****************************

We spent roughly 22 hours on this assignment.
